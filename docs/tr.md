# Техническое решение проекта «Map-Reduce word count»

## Введение

**Цель проекта:**
Разработать распределенную систему на основе парадигмы Map-Reduce для задачи подсчета количества слов в документе (word count). Проект служит демонстрацией принципов распределенных вычислений и отказоустойчивой обработки данных.

**Основания для разработки:**
Учебный проект в рамках курса «Основы распределенных вычислений». Проект демонстрирует практическое применение MapReduce-подхода для обработки текстовых документов.

**Команда:**
- Александр Кука — Разработчик / Архитектор
- Клименко Степан — Аналитик / Тестировщик  
- Скудаева Варвара — Data Engineer

---

## Глоссарий

| Термин | Определение |
|--------|-------------|
| **MapReduce** | Модель распределённых вычислений для параллельной обработки больших данных путем разделения задачи на этапы **Map** и **Reduce** |
| **Map (Фаза отображения)** | Стадия обработки, на которой входные данные разбиваются на части и обрабатываются параллельно для генерации промежуточных пар ключ-значение |
| **Reduce (Фаза свертки)** | Стадия обработки, на которой промежуточные данные группируются по ключу и агрегируются для формирования финального результата |
| **Planner (Планировщик)** | Центральный координирующий сервис, отвечающий за прием задач, распределение работы между узлами и управление жизненным циклом задачи |
| **Универсальный Узел (Worker Node)** | Вычислительный узел в кластере, способный выполнять как **Map**, так и **Reduce** задачи |
| **Shuffle & Sort** | Этап между Map и Reduce, на котором промежуточные пары ключ-значение группируются по ключу и сортируются перед отправкой на Reduce-узлы |
| **Task Manager** | Сервис, отвечающий за мониторинг состояния выполнения задач и системы |
| **Чанк (Chunk)** | Часть входного документа, обрабатываемая на этапе Map |
| **Воркер (Worker)** | Процесс, выполняющий задачи Map или Reduce на узле |

---

## Функциональные требования

Система должна предоставлять следующие функции:

1. **Загрузка документа** - Пользователь загружает текстовый документ через пользовательский интерфейс
2. **Распределение задач** - Сервис **Planner** разбивает документ на чанки и распределяет **Map-задачи** между доступными узлами
3. **Параллельный подсчет слов** - Узлы выполняют **Map-задачу**, обрабатывая свои чанки и генерируя промежуточные данные (`<слово, 1>`)
4. **Агрегация результатов** - Система автоматически выполняет этап **Shuffle & Sort**, группируя промежуточные данные по словам
5. **Формирование выходного файла** - Узлы, назначенные на **Reduce-задачу**, суммируют количества для каждого слова
6. **Сохранение результатов** - Финальный результат сохраняется в базу данных
7. **Уведомление о завершении** - **Task Manager** отслеживает результат и уведомляет **Planner** о завершении задачи

---

## Нефункциональные требования

### Производительность
- Обработка документа объемом 1 ГБ должна быть завершена не более чем за X минут
- Система должна демонстрировать линейное или близкое к линейному ускорение при добавлении новых узлов

### Масштабируемость
- Архитектура позволяет горизонтально масштабироваться за счет добавления новых **Универсальных Узлов**

### Надежность и отказоустойчивость
- **Planner** должен отслеживать "здоровье" узлов
- В случае падения узла задача должна быть переназначена другому доступному узлу
- Результаты этапа **Map** должны сохраняться в устойчивое хранилище

### Простота использования
- Процесс загрузки документа и получения результата должен быть интуитивно понятен

---

## Пользовательские сценарии

### Сценарий: Подсчет слов в документе
Пользователь загружает в узел распределенной системы документ, на выходе получает итоговый файл с количеством каждого из слов в тексте
---

## Архитектура системы
```mermaid
flowchart TB
 subgraph Masters["Управляющие узлы"]
        A["Planner"]
        F["Task Manager"]
  end
 subgraph Workers["Рабочие узлы"]
        B["Worker Node 1"]
        C["Worker Node 2"]
        D["Worker Node 3"]
  end
 subgraph Infrastructure["Инфраструктура"]
        E["Database"]
  end
    A --> B & C & D
    B --> E
    C --> E
    D --> E
    F --> E & A
     A:::planner
     F:::manager
     B:::worker
     C:::worker
     D:::worker
     E:::database
    classDef planner fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef worker fill:#f3e5f5,stroke:#4a148c,stroke-width:1px
    classDef database fill:#e8f5e8,stroke:#1b5e20,stroke-width:1px
    classDef manager fill:#fff3e0,stroke:#e65100,stroke-width:1px
 \```

Система построена по гибридной архитектуре "Master-Worker" в рамках парадигмы MapReduce.

### Компоненты системы

**Planner (Master)**
- Центральный узел-координатор
- Принимает задачи от пользователя
- Управляет распределением данных (чанки)
- Назначает задачи (**Map** и **Reduce**) универсальным узлам
- Отслеживает статус узлов и обрабатывает сбои

**Универсальные Узлы (Workers)**
- Исполняющие узлы, способные выполнять обе функции:
  - **Map**: Принимает фрагмент текста, разбивает на отдельные слова, формирует промежуточные результаты в формате `(<слово>, 1)`
  - **Reduce**: Получает сгруппированные данные по определенным словам, складывает все единицы и вычисляет итоговое количество для каждого слова

**Shuffle & Sort**
- Промежуточные данные с всех узлов собираются и организуются
- Данные группируются по словам и упорядочиваются для эффективной обработки

**Task Manager**
- Постоянно проверяет базу данных на появление новых результатов
- Определяет окончание процесса обработки
- Сообщает Planner о готовности узлов к новым задачам

**База данных**
- Финальное хранилище результатов подсчета
---

## Технические сценарии

### Сценарий 1: Успешное выполнение задачи Word Count

1. Planner получает документ, разбивает его на 4 чанка
2. Planner назначает 4 Map-задачи на 4 доступных узла (Node1, Node2, Node3, Node4)
3. Узлы выполняют Map, генерируя промежуточные данные
4. Planner назначает 2 Reduce-задачи (Node1 и Node2)
5. Промежуточные данные перемешиваются и отправляются на Reduce-узлы
6. Node1 и Node2 выполняют Reduce, суммируя значения
7. Reduce-узлы записывают финальные результаты в БД
8. Task Manager обнаруживает новую запись и уведомляет Planner
9. Planner отмечает задачу как выполненную и уведомляет пользователя

### Сценарий 2: Обработка сбоя узла

1. Node3 перестает отвечать до завершения своей Map-задачи
2. Planner обнаруживает сбой Node3
3. Planner повторно ставит Map-задачу в очередь и назначает ее свободному узлу
4. Процесс продолжается с этапа Shuffle & Sort

---

## План разработки и тестирования

### План разработки (Итеративный подход)

**Фаза 1: Прототип на одном узле**
- Цель: Реализовать логику Map и Reduce в рамках одного приложения
- Результат: Консольное приложение для word count

**Фаза 2: Planner и один Worker**
- Цель: Разделить ответственность между компонентами
- Результат: Два приложения, коммуницирующих по сети

**Фаза 3: Распределение Map-задач**
- Цель: Реализовать запуск нескольких Worker'ов
- Результат: Planner может отправить чанки разным Worker'ам

**Фаза 4: Shuffle & Sort и Reduce-задачи**
- Цель: Организовать передачу данных между Worker'ами
- Результат: Полностью работоспособный конвейер MapReduce

**Фаза 5: Интеграция с БД и Task Manager**
- Цель: Добавить устойчивое хранение и автоматическое оповещение
- Результат: Конечная архитектура системы

**Фаза 6: Пользовательский веб-интерфейс**
- Цель: Предоставить удобный способ взаимодействия

### Тестирование

**Интеграционное тестирование (Integration Testing)**
- Тестирование взаимодействия между **Planner** и **Worker**
- Тестирование взаимодействия **Worker** с БД
- Тестирование цикла **Task Manager** → **БД** → **Planner**

**Системное тестирование (System / End-to-End Testing)**
- Запуск всего кластера с тестовыми документами разного размера
- Проверка корректности и полноты итогового результата
- Проверка работы под нагрузкой

**Тестирование отказоустойчивости (Failure Testing)**
- Имитация падения Worker'а во время выполнения задач
- Проверка переназначения задач и корректности конечного результата
- Проверка восстановления системы после перезапуска узлов

### DOD
- Система должна корректно решать задачу подсчета слов (word count)
- Система должна решать задачу распределено в соответствии с заявленной архитектурой

